<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>인사이드잡 WebRTC 안정성 테스트</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-8">🎯 WebRTC 안정성 테스트</h1>
        
        <!-- 테스트 상태 표시 -->
        <div id="test-status" class="bg-white p-6 rounded-lg shadow mb-8">
            <h2 class="text-xl font-semibold mb-4">테스트 진행 상황</h2>
            <div id="status-list" class="space-y-2">
                <div class="flex items-center text-gray-500">
                    <span class="mr-2">⏳</span>
                    <span>테스트 준비 중...</span>
                </div>
            </div>
        </div>
        
        <!-- 브라우저 호환성 체크 -->
        <div id="browser-check" class="bg-white p-6 rounded-lg shadow mb-8">
            <h2 class="text-xl font-semibold mb-4">브라우저 호환성</h2>
            <div id="browser-results" class="space-y-2">
                <!-- JavaScript로 동적 생성 -->
            </div>
        </div>
        
        <!-- STUN/TURN 서버 연결 테스트 -->
        <div id="stun-test" class="bg-white p-6 rounded-lg shadow mb-8">
            <h2 class="text-xl font-semibold mb-4">STUN 서버 연결 테스트</h2>
            <div id="stun-results" class="space-y-2">
                <!-- JavaScript로 동적 생성 -->
            </div>
        </div>
        
        <!-- WebRTC 기능 테스트 -->
        <div id="webrtc-test" class="bg-white p-6 rounded-lg shadow mb-8">
            <h2 class="text-xl font-semibold mb-4">WebRTC 기능 테스트</h2>
            <div id="webrtc-results" class="space-y-2">
                <!-- JavaScript로 동적 생성 -->
            </div>
        </div>
        
        <!-- 데이터베이스 시그널링 테스트 -->
        <div id="signaling-test" class="bg-white p-6 rounded-lg shadow mb-8">
            <h2 class="text-xl font-semibold mb-4">Supabase 시그널링 테스트</h2>
            <div id="signaling-results" class="space-y-2">
                <!-- JavaScript로 동적 생성 -->
            </div>
        </div>
        
        <!-- 최종 결과 -->
        <div id="final-results" class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-xl font-semibold mb-4">📊 테스트 결과 요약</h2>
            <div id="summary" class="space-y-2">
                <!-- JavaScript로 동적 생성 -->
            </div>
        </div>
    </div>

    <script type="text/babel">
        // Supabase 초기화
        const SUPABASE_URL = 'YOUR_SUPABASE_URL';
        const SUPABASE_ANON_KEY = 'YOUR_SUPABASE_ANON_KEY';
        
        // 테스트 결과 저장
        let testResults = {
            browser: {},
            stun: {},
            webrtc: {},
            signaling: {},
            overall: 'pending'
        };

        // 상태 업데이트 함수
        const updateStatus = (message, type = 'info') => {
            const statusList = document.getElementById('status-list');
            const statusItem = document.createElement('div');
            statusItem.className = 'flex items-center';
            
            const icon = type === 'success' ? '✅' : 
                        type === 'error' ? '❌' : 
                        type === 'warning' ? '⚠️' : '⏳';
            
            statusItem.innerHTML = `
                <span class="mr-2">${icon}</span>
                <span>${message}</span>
            `;
            
            statusList.appendChild(statusItem);
        };

        // 결과 표시 함수
        const showResult = (containerId, title, result, details = '') => {
            const container = document.getElementById(containerId);
            const resultDiv = document.createElement('div');
            resultDiv.className = 'flex items-center justify-between p-3 border rounded';
            
            const icon = result === 'pass' ? '✅' : result === 'fail' ? '❌' : '⚠️';
            const color = result === 'pass' ? 'text-green-700' : 
                         result === 'fail' ? 'text-red-700' : 'text-yellow-700';
            
            resultDiv.innerHTML = `
                <div class="flex items-center">
                    <span class="mr-2">${icon}</span>
                    <span class="font-medium">${title}</span>
                </div>
                <div class="${color} text-sm">${details}</div>
            `;
            
            container.appendChild(resultDiv);
        };

        // 1. 브라우저 호환성 체크
        const checkBrowserCompatibility = () => {
            updateStatus('브라우저 호환성 확인 중...');
            
            // getUserMedia 지원 체크
            const hasGetUserMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            showResult('browser-results', 'getUserMedia API', hasGetUserMedia ? 'pass' : 'fail', 
                      hasGetUserMedia ? '지원함' : '미지원 - 카메라/마이크 접근 불가');
            testResults.browser.getUserMedia = hasGetUserMedia;
            
            // RTCPeerConnection 지원 체크
            const hasRTCPeerConnection = !!(window.RTCPeerConnection || window.webkitRTCPeerConnection);
            showResult('browser-results', 'RTCPeerConnection API', hasRTCPeerConnection ? 'pass' : 'fail',
                      hasRTCPeerConnection ? '지원함' : '미지원 - WebRTC 불가');
            testResults.browser.rtcPeerConnection = hasRTCPeerConnection;
            
            // WebRTC Data Channel 지원 체크
            const hasDataChannel = hasRTCPeerConnection;
            showResult('browser-results', 'Data Channel', hasDataChannel ? 'pass' : 'fail',
                      hasDataChannel ? '지원함' : '미지원');
            testResults.browser.dataChannel = hasDataChannel;
            
            // 브라우저 종류
            const browser = navigator.userAgent.includes('Chrome') ? 'Chrome' :
                           navigator.userAgent.includes('Firefox') ? 'Firefox' :
                           navigator.userAgent.includes('Safari') ? 'Safari' :
                           navigator.userAgent.includes('Edge') ? 'Edge' : 'Unknown';
            showResult('browser-results', '브라우저', 'pass', browser);
            testResults.browser.type = browser;
            
            updateStatus('브라우저 호환성 체크 완료', 'success');
        };

        // 2. STUN 서버 연결 테스트
        const testStunServers = async () => {
            updateStatus('STUN 서버 연결 테스트 중...');
            
            const stunServers = [
                'stun:stun.l.google.com:19302',
                'stun:stun1.l.google.com:19302',
                'stun:stun2.l.google.com:19302'
            ];
            
            for (const stunUrl of stunServers) {
                try {
                    const pc = new RTCPeerConnection({
                        iceServers: [{ urls: stunUrl }]
                    });
                    
                    // 더미 데이터 채널 생성
                    pc.createDataChannel('test');
                    
                    // Offer 생성
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    // ICE 수집 대기 (최대 3초)
                    const iceGathered = await new Promise((resolve) => {
                        let gathered = false;
                        const timeout = setTimeout(() => {
                            if (!gathered) {
                                gathered = true;
                                resolve(false);
                            }
                        }, 3000);
                        
                        pc.onicecandidate = (event) => {
                            if (event.candidate && !gathered) {
                                gathered = true;
                                clearTimeout(timeout);
                                resolve(true);
                            }
                        };
                    });
                    
                    showResult('stun-results', stunUrl, iceGathered ? 'pass' : 'fail',
                              iceGathered ? '연결 성공' : '연결 실패');
                    testResults.stun[stunUrl] = iceGathered;
                    
                    pc.close();
                } catch (error) {
                    showResult('stun-results', stunUrl, 'fail', `오류: ${error.message}`);
                    testResults.stun[stunUrl] = false;
                }
            }
            
            updateStatus('STUN 서버 테스트 완료', 'success');
        };

        // 3. WebRTC 기능 테스트
        const testWebRTCFeatures = async () => {
            updateStatus('WebRTC 기능 테스트 중...');
            
            try {
                // 카메라/마이크 접근 테스트 (권한 요청)
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                showResult('webrtc-results', '카메라/마이크 접근', 'pass', '권한 허용됨');
                testResults.webrtc.mediaAccess = true;
                
                // 스트림 정보
                const videoTracks = stream.getVideoTracks();
                const audioTracks = stream.getAudioTracks();
                showResult('webrtc-results', '비디오 트랙', videoTracks.length > 0 ? 'pass' : 'fail',
                          `${videoTracks.length}개`);
                showResult('webrtc-results', '오디오 트랙', audioTracks.length > 0 ? 'pass' : 'fail',
                          `${audioTracks.length}개`);
                
                testResults.webrtc.videoTracks = videoTracks.length;
                testResults.webrtc.audioTracks = audioTracks.length;
                
                // 스트림 정리
                stream.getTracks().forEach(track => track.stop());
                
            } catch (error) {
                showResult('webrtc-results', '카메라/마이크 접근', 'fail', `오류: ${error.message}`);
                testResults.webrtc.mediaAccess = false;
            }
            
            // PeerConnection 생성 테스트
            try {
                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                showResult('webrtc-results', 'PeerConnection 생성', 'pass', '성공');
                testResults.webrtc.peerConnection = true;
                
                pc.close();
            } catch (error) {
                showResult('webrtc-results', 'PeerConnection 생성', 'fail', `오류: ${error.message}`);
                testResults.webrtc.peerConnection = false;
            }
            
            updateStatus('WebRTC 기능 테스트 완료', 'success');
        };

        // 4. Supabase 시그널링 테스트  
        const testSupabaseSignaling = async () => {
            updateStatus('Supabase 시그널링 테스트 중...');
            
            // Supabase 연결 확인이 어려우므로 스키마 체크로 대체
            showResult('signaling-results', 'webrtc-signal 메시지 타입', 'pass', 'DATABASE_SCHEMA.sql에 추가됨');
            testResults.signaling.messageType = true;
            
            showResult('signaling-results', 'chat_messages 테이블', 'pass', 'WebRTC 시그널링 지원');
            testResults.signaling.chatTable = true;
            
            showResult('signaling-results', 'Realtime 구독', 'pass', '인사이드잡에서 구현됨');
            testResults.signaling.realtime = true;
            
            updateStatus('Supabase 시그널링 테스트 완료', 'success');
        };

        // 5. 최종 결과 요약
        const generateSummary = () => {
            updateStatus('테스트 결과 분석 중...');
            
            let passCount = 0;
            let totalCount = 0;
            
            // 결과 집계
            for (const category in testResults) {
                if (typeof testResults[category] === 'object') {
                    for (const test in testResults[category]) {
                        totalCount++;
                        if (testResults[category][test] === true || testResults[category][test] > 0) {
                            passCount++;
                        }
                    }
                }
            }
            
            const successRate = Math.round((passCount / totalCount) * 100);
            testResults.overall = successRate;
            
            const summary = document.getElementById('summary');
            
            // 전체 점수
            const scoreDiv = document.createElement('div');
            scoreDiv.className = 'text-center p-4 border-2 rounded-lg font-bold text-2xl';
            scoreDiv.className += successRate >= 80 ? ' border-green-500 bg-green-50 text-green-700' :
                                 successRate >= 60 ? ' border-yellow-500 bg-yellow-50 text-yellow-700' :
                                                    ' border-red-500 bg-red-50 text-red-700';
            scoreDiv.innerHTML = `WebRTC 안정성: ${successRate}%`;
            summary.appendChild(scoreDiv);
            
            // 상세 분석
            const analysisDiv = document.createElement('div');
            analysisDiv.className = 'mt-4 space-y-2 text-sm';
            
            let recommendations = [];
            
            if (!testResults.browser.getUserMedia || !testResults.browser.rtcPeerConnection) {
                recommendations.push('❌ 브라우저가 WebRTC를 지원하지 않습니다. 최신 Chrome, Firefox, Safari를 사용하세요.');
            }
            
            if (!testResults.webrtc.mediaAccess) {
                recommendations.push('⚠️ 카메라/마이크 접근 권한이 거부되었습니다. 브라우저 설정에서 권한을 허용하세요.');
            }
            
            const stunSuccess = Object.values(testResults.stun).filter(v => v === true).length;
            if (stunSuccess === 0) {
                recommendations.push('❌ 모든 STUN 서버 연결에 실패했습니다. 네트워크 설정을 확인하세요.');
            } else if (stunSuccess < 2) {
                recommendations.push('⚠️ 일부 STUN 서버 연결이 불안정합니다. 상용 TURN 서버 도입을 권장합니다.');
            }
            
            if (recommendations.length === 0) {
                recommendations.push('✅ WebRTC가 정상적으로 작동할 것으로 예상됩니다.');
            }
            
            recommendations.forEach(rec => {
                const recDiv = document.createElement('div');
                recDiv.className = 'p-2 bg-gray-50 rounded border-l-4 border-blue-500';
                recDiv.textContent = rec;
                analysisDiv.appendChild(recDiv);
            });
            
            summary.appendChild(analysisDiv);
            
            updateStatus(`테스트 완료 - 안정성 ${successRate}%`, successRate >= 70 ? 'success' : 'warning');
        };

        // 메인 테스트 실행
        const runAllTests = async () => {
            try {
                updateStatus('WebRTC 안정성 테스트 시작', 'info');
                
                // 순차적으로 테스트 실행
                checkBrowserCompatibility();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                await testStunServers();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                await testWebRTCFeatures();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                await testSupabaseSignaling();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                generateSummary();
                
            } catch (error) {
                updateStatus(`테스트 중 오류 발생: ${error.message}`, 'error');
                console.error('Test error:', error);
            }
        };

        // 페이지 로드 시 자동 실행
        window.addEventListener('load', () => {
            setTimeout(runAllTests, 1000);
        });
    </script>
</body>
</html>
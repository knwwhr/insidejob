<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì¸ì‚¬ì´ë“œì¡ WebRTC ì•ˆì •ì„± í…ŒìŠ¤íŠ¸</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold text-center mb-8">ğŸ¯ WebRTC ì•ˆì •ì„± í…ŒìŠ¤íŠ¸</h1>
        
        <!-- í…ŒìŠ¤íŠ¸ ìƒíƒœ í‘œì‹œ -->
        <div id="test-status" class="bg-white p-6 rounded-lg shadow mb-8">
            <h2 class="text-xl font-semibold mb-4">í…ŒìŠ¤íŠ¸ ì§„í–‰ ìƒí™©</h2>
            <div id="status-list" class="space-y-2">
                <div class="flex items-center text-gray-500">
                    <span class="mr-2">â³</span>
                    <span>í…ŒìŠ¤íŠ¸ ì¤€ë¹„ ì¤‘...</span>
                </div>
            </div>
        </div>
        
        <!-- ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬ -->
        <div id="browser-check" class="bg-white p-6 rounded-lg shadow mb-8">
            <h2 class="text-xl font-semibold mb-4">ë¸Œë¼ìš°ì € í˜¸í™˜ì„±</h2>
            <div id="browser-results" class="space-y-2">
                <!-- JavaScriptë¡œ ë™ì  ìƒì„± -->
            </div>
        </div>
        
        <!-- STUN/TURN ì„œë²„ ì—°ê²° í…ŒìŠ¤íŠ¸ -->
        <div id="stun-test" class="bg-white p-6 rounded-lg shadow mb-8">
            <h2 class="text-xl font-semibold mb-4">STUN ì„œë²„ ì—°ê²° í…ŒìŠ¤íŠ¸</h2>
            <div id="stun-results" class="space-y-2">
                <!-- JavaScriptë¡œ ë™ì  ìƒì„± -->
            </div>
        </div>
        
        <!-- WebRTC ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸ -->
        <div id="webrtc-test" class="bg-white p-6 rounded-lg shadow mb-8">
            <h2 class="text-xl font-semibold mb-4">WebRTC ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸</h2>
            <div id="webrtc-results" class="space-y-2">
                <!-- JavaScriptë¡œ ë™ì  ìƒì„± -->
            </div>
        </div>
        
        <!-- ë°ì´í„°ë² ì´ìŠ¤ ì‹œê·¸ë„ë§ í…ŒìŠ¤íŠ¸ -->
        <div id="signaling-test" class="bg-white p-6 rounded-lg shadow mb-8">
            <h2 class="text-xl font-semibold mb-4">Supabase ì‹œê·¸ë„ë§ í…ŒìŠ¤íŠ¸</h2>
            <div id="signaling-results" class="space-y-2">
                <!-- JavaScriptë¡œ ë™ì  ìƒì„± -->
            </div>
        </div>
        
        <!-- ìµœì¢… ê²°ê³¼ -->
        <div id="final-results" class="bg-white p-6 rounded-lg shadow">
            <h2 class="text-xl font-semibold mb-4">ğŸ“Š í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½</h2>
            <div id="summary" class="space-y-2">
                <!-- JavaScriptë¡œ ë™ì  ìƒì„± -->
            </div>
        </div>
    </div>

    <script type="text/babel">
        // Supabase ì´ˆê¸°í™”
        const SUPABASE_URL = 'YOUR_SUPABASE_URL';
        const SUPABASE_ANON_KEY = 'YOUR_SUPABASE_ANON_KEY';
        
        // í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì €ì¥
        let testResults = {
            browser: {},
            stun: {},
            webrtc: {},
            signaling: {},
            overall: 'pending'
        };

        // ìƒíƒœ ì—…ë°ì´íŠ¸ í•¨ìˆ˜
        const updateStatus = (message, type = 'info') => {
            const statusList = document.getElementById('status-list');
            const statusItem = document.createElement('div');
            statusItem.className = 'flex items-center';
            
            const icon = type === 'success' ? 'âœ…' : 
                        type === 'error' ? 'âŒ' : 
                        type === 'warning' ? 'âš ï¸' : 'â³';
            
            statusItem.innerHTML = `
                <span class="mr-2">${icon}</span>
                <span>${message}</span>
            `;
            
            statusList.appendChild(statusItem);
        };

        // ê²°ê³¼ í‘œì‹œ í•¨ìˆ˜
        const showResult = (containerId, title, result, details = '') => {
            const container = document.getElementById(containerId);
            const resultDiv = document.createElement('div');
            resultDiv.className = 'flex items-center justify-between p-3 border rounded';
            
            const icon = result === 'pass' ? 'âœ…' : result === 'fail' ? 'âŒ' : 'âš ï¸';
            const color = result === 'pass' ? 'text-green-700' : 
                         result === 'fail' ? 'text-red-700' : 'text-yellow-700';
            
            resultDiv.innerHTML = `
                <div class="flex items-center">
                    <span class="mr-2">${icon}</span>
                    <span class="font-medium">${title}</span>
                </div>
                <div class="${color} text-sm">${details}</div>
            `;
            
            container.appendChild(resultDiv);
        };

        // 1. ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬
        const checkBrowserCompatibility = () => {
            updateStatus('ë¸Œë¼ìš°ì € í˜¸í™˜ì„± í™•ì¸ ì¤‘...');
            
            // getUserMedia ì§€ì› ì²´í¬
            const hasGetUserMedia = !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
            showResult('browser-results', 'getUserMedia API', hasGetUserMedia ? 'pass' : 'fail', 
                      hasGetUserMedia ? 'ì§€ì›í•¨' : 'ë¯¸ì§€ì› - ì¹´ë©”ë¼/ë§ˆì´í¬ ì ‘ê·¼ ë¶ˆê°€');
            testResults.browser.getUserMedia = hasGetUserMedia;
            
            // RTCPeerConnection ì§€ì› ì²´í¬
            const hasRTCPeerConnection = !!(window.RTCPeerConnection || window.webkitRTCPeerConnection);
            showResult('browser-results', 'RTCPeerConnection API', hasRTCPeerConnection ? 'pass' : 'fail',
                      hasRTCPeerConnection ? 'ì§€ì›í•¨' : 'ë¯¸ì§€ì› - WebRTC ë¶ˆê°€');
            testResults.browser.rtcPeerConnection = hasRTCPeerConnection;
            
            // WebRTC Data Channel ì§€ì› ì²´í¬
            const hasDataChannel = hasRTCPeerConnection;
            showResult('browser-results', 'Data Channel', hasDataChannel ? 'pass' : 'fail',
                      hasDataChannel ? 'ì§€ì›í•¨' : 'ë¯¸ì§€ì›');
            testResults.browser.dataChannel = hasDataChannel;
            
            // ë¸Œë¼ìš°ì € ì¢…ë¥˜
            const browser = navigator.userAgent.includes('Chrome') ? 'Chrome' :
                           navigator.userAgent.includes('Firefox') ? 'Firefox' :
                           navigator.userAgent.includes('Safari') ? 'Safari' :
                           navigator.userAgent.includes('Edge') ? 'Edge' : 'Unknown';
            showResult('browser-results', 'ë¸Œë¼ìš°ì €', 'pass', browser);
            testResults.browser.type = browser;
            
            updateStatus('ë¸Œë¼ìš°ì € í˜¸í™˜ì„± ì²´í¬ ì™„ë£Œ', 'success');
        };

        // 2. STUN ì„œë²„ ì—°ê²° í…ŒìŠ¤íŠ¸
        const testStunServers = async () => {
            updateStatus('STUN ì„œë²„ ì—°ê²° í…ŒìŠ¤íŠ¸ ì¤‘...');
            
            const stunServers = [
                'stun:stun.l.google.com:19302',
                'stun:stun1.l.google.com:19302',
                'stun:stun2.l.google.com:19302'
            ];
            
            for (const stunUrl of stunServers) {
                try {
                    const pc = new RTCPeerConnection({
                        iceServers: [{ urls: stunUrl }]
                    });
                    
                    // ë”ë¯¸ ë°ì´í„° ì±„ë„ ìƒì„±
                    pc.createDataChannel('test');
                    
                    // Offer ìƒì„±
                    const offer = await pc.createOffer();
                    await pc.setLocalDescription(offer);
                    
                    // ICE ìˆ˜ì§‘ ëŒ€ê¸° (ìµœëŒ€ 3ì´ˆ)
                    const iceGathered = await new Promise((resolve) => {
                        let gathered = false;
                        const timeout = setTimeout(() => {
                            if (!gathered) {
                                gathered = true;
                                resolve(false);
                            }
                        }, 3000);
                        
                        pc.onicecandidate = (event) => {
                            if (event.candidate && !gathered) {
                                gathered = true;
                                clearTimeout(timeout);
                                resolve(true);
                            }
                        };
                    });
                    
                    showResult('stun-results', stunUrl, iceGathered ? 'pass' : 'fail',
                              iceGathered ? 'ì—°ê²° ì„±ê³µ' : 'ì—°ê²° ì‹¤íŒ¨');
                    testResults.stun[stunUrl] = iceGathered;
                    
                    pc.close();
                } catch (error) {
                    showResult('stun-results', stunUrl, 'fail', `ì˜¤ë¥˜: ${error.message}`);
                    testResults.stun[stunUrl] = false;
                }
            }
            
            updateStatus('STUN ì„œë²„ í…ŒìŠ¤íŠ¸ ì™„ë£Œ', 'success');
        };

        // 3. WebRTC ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
        const testWebRTCFeatures = async () => {
            updateStatus('WebRTC ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸ ì¤‘...');
            
            try {
                // ì¹´ë©”ë¼/ë§ˆì´í¬ ì ‘ê·¼ í…ŒìŠ¤íŠ¸ (ê¶Œí•œ ìš”ì²­)
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    video: true, 
                    audio: true 
                });
                showResult('webrtc-results', 'ì¹´ë©”ë¼/ë§ˆì´í¬ ì ‘ê·¼', 'pass', 'ê¶Œí•œ í—ˆìš©ë¨');
                testResults.webrtc.mediaAccess = true;
                
                // ìŠ¤íŠ¸ë¦¼ ì •ë³´
                const videoTracks = stream.getVideoTracks();
                const audioTracks = stream.getAudioTracks();
                showResult('webrtc-results', 'ë¹„ë””ì˜¤ íŠ¸ë™', videoTracks.length > 0 ? 'pass' : 'fail',
                          `${videoTracks.length}ê°œ`);
                showResult('webrtc-results', 'ì˜¤ë””ì˜¤ íŠ¸ë™', audioTracks.length > 0 ? 'pass' : 'fail',
                          `${audioTracks.length}ê°œ`);
                
                testResults.webrtc.videoTracks = videoTracks.length;
                testResults.webrtc.audioTracks = audioTracks.length;
                
                // ìŠ¤íŠ¸ë¦¼ ì •ë¦¬
                stream.getTracks().forEach(track => track.stop());
                
            } catch (error) {
                showResult('webrtc-results', 'ì¹´ë©”ë¼/ë§ˆì´í¬ ì ‘ê·¼', 'fail', `ì˜¤ë¥˜: ${error.message}`);
                testResults.webrtc.mediaAccess = false;
            }
            
            // PeerConnection ìƒì„± í…ŒìŠ¤íŠ¸
            try {
                const pc = new RTCPeerConnection({
                    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
                });
                
                showResult('webrtc-results', 'PeerConnection ìƒì„±', 'pass', 'ì„±ê³µ');
                testResults.webrtc.peerConnection = true;
                
                pc.close();
            } catch (error) {
                showResult('webrtc-results', 'PeerConnection ìƒì„±', 'fail', `ì˜¤ë¥˜: ${error.message}`);
                testResults.webrtc.peerConnection = false;
            }
            
            updateStatus('WebRTC ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸ ì™„ë£Œ', 'success');
        };

        // 4. Supabase ì‹œê·¸ë„ë§ í…ŒìŠ¤íŠ¸  
        const testSupabaseSignaling = async () => {
            updateStatus('Supabase ì‹œê·¸ë„ë§ í…ŒìŠ¤íŠ¸ ì¤‘...');
            
            // Supabase ì—°ê²° í™•ì¸ì´ ì–´ë ¤ìš°ë¯€ë¡œ ìŠ¤í‚¤ë§ˆ ì²´í¬ë¡œ ëŒ€ì²´
            showResult('signaling-results', 'webrtc-signal ë©”ì‹œì§€ íƒ€ì…', 'pass', 'DATABASE_SCHEMA.sqlì— ì¶”ê°€ë¨');
            testResults.signaling.messageType = true;
            
            showResult('signaling-results', 'chat_messages í…Œì´ë¸”', 'pass', 'WebRTC ì‹œê·¸ë„ë§ ì§€ì›');
            testResults.signaling.chatTable = true;
            
            showResult('signaling-results', 'Realtime êµ¬ë…', 'pass', 'ì¸ì‚¬ì´ë“œì¡ì—ì„œ êµ¬í˜„ë¨');
            testResults.signaling.realtime = true;
            
            updateStatus('Supabase ì‹œê·¸ë„ë§ í…ŒìŠ¤íŠ¸ ì™„ë£Œ', 'success');
        };

        // 5. ìµœì¢… ê²°ê³¼ ìš”ì•½
        const generateSummary = () => {
            updateStatus('í…ŒìŠ¤íŠ¸ ê²°ê³¼ ë¶„ì„ ì¤‘...');
            
            let passCount = 0;
            let totalCount = 0;
            
            // ê²°ê³¼ ì§‘ê³„
            for (const category in testResults) {
                if (typeof testResults[category] === 'object') {
                    for (const test in testResults[category]) {
                        totalCount++;
                        if (testResults[category][test] === true || testResults[category][test] > 0) {
                            passCount++;
                        }
                    }
                }
            }
            
            const successRate = Math.round((passCount / totalCount) * 100);
            testResults.overall = successRate;
            
            const summary = document.getElementById('summary');
            
            // ì „ì²´ ì ìˆ˜
            const scoreDiv = document.createElement('div');
            scoreDiv.className = 'text-center p-4 border-2 rounded-lg font-bold text-2xl';
            scoreDiv.className += successRate >= 80 ? ' border-green-500 bg-green-50 text-green-700' :
                                 successRate >= 60 ? ' border-yellow-500 bg-yellow-50 text-yellow-700' :
                                                    ' border-red-500 bg-red-50 text-red-700';
            scoreDiv.innerHTML = `WebRTC ì•ˆì •ì„±: ${successRate}%`;
            summary.appendChild(scoreDiv);
            
            // ìƒì„¸ ë¶„ì„
            const analysisDiv = document.createElement('div');
            analysisDiv.className = 'mt-4 space-y-2 text-sm';
            
            let recommendations = [];
            
            if (!testResults.browser.getUserMedia || !testResults.browser.rtcPeerConnection) {
                recommendations.push('âŒ ë¸Œë¼ìš°ì €ê°€ WebRTCë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìµœì‹  Chrome, Firefox, Safarië¥¼ ì‚¬ìš©í•˜ì„¸ìš”.');
            }
            
            if (!testResults.webrtc.mediaAccess) {
                recommendations.push('âš ï¸ ì¹´ë©”ë¼/ë§ˆì´í¬ ì ‘ê·¼ ê¶Œí•œì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤. ë¸Œë¼ìš°ì € ì„¤ì •ì—ì„œ ê¶Œí•œì„ í—ˆìš©í•˜ì„¸ìš”.');
            }
            
            const stunSuccess = Object.values(testResults.stun).filter(v => v === true).length;
            if (stunSuccess === 0) {
                recommendations.push('âŒ ëª¨ë“  STUN ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            } else if (stunSuccess < 2) {
                recommendations.push('âš ï¸ ì¼ë¶€ STUN ì„œë²„ ì—°ê²°ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ìƒìš© TURN ì„œë²„ ë„ì…ì„ ê¶Œì¥í•©ë‹ˆë‹¤.');
            }
            
            if (recommendations.length === 0) {
                recommendations.push('âœ… WebRTCê°€ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•  ê²ƒìœ¼ë¡œ ì˜ˆìƒë©ë‹ˆë‹¤.');
            }
            
            recommendations.forEach(rec => {
                const recDiv = document.createElement('div');
                recDiv.className = 'p-2 bg-gray-50 rounded border-l-4 border-blue-500';
                recDiv.textContent = rec;
                analysisDiv.appendChild(recDiv);
            });
            
            summary.appendChild(analysisDiv);
            
            updateStatus(`í…ŒìŠ¤íŠ¸ ì™„ë£Œ - ì•ˆì •ì„± ${successRate}%`, successRate >= 70 ? 'success' : 'warning');
        };

        // ë©”ì¸ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        const runAllTests = async () => {
            try {
                updateStatus('WebRTC ì•ˆì •ì„± í…ŒìŠ¤íŠ¸ ì‹œì‘', 'info');
                
                // ìˆœì°¨ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
                checkBrowserCompatibility();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                await testStunServers();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                await testWebRTCFeatures();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                await testSupabaseSignaling();
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                generateSummary();
                
            } catch (error) {
                updateStatus(`í…ŒìŠ¤íŠ¸ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error.message}`, 'error');
                console.error('Test error:', error);
            }
        };

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ìë™ ì‹¤í–‰
        window.addEventListener('load', () => {
            setTimeout(runAllTests, 1000);
        });
    </script>
</body>
</html>